<?xml version="1.0" encoding="iso-8859-1"?>
<html>
<head><title>LSP User Guide</title></head>
<link rel="stylesheet" type="text/css" href="manual.css" />
<body>
<h1>LSP User Guide</h1>

<h2>Overview</h2>

<p>LSP is a technology for pseudo-dynamic content processing.</p>

<p>The design of LSP is inspired by dynamic content technologies,
especially JSP, and by XML technologies, especially XSLT.</p>

<p>LSP is fully based on XML and namespaces. This means that it's easy
to efficiently use LSP together with other XML technologies, such as
XSLT (for example, an LSP page can be constructed with XSLT, and you
can process the output of LSP with XSLT).</p>


<h2>LSP basics</h2>

<p>An LSP page is a well-formed XML document, composed of elements from
the LSP namespace and from other namespaces (including the null
namespace). The document root element may, but doesn't have to, be in
the LSP namespace.</p>

<p>The namespace URI for LSP is
<code>http://staldal.nu/LSP/core</code>. In this document, it's assumed
that this namespace is mapped to the prefix <code>lsp</code>, however
any prefix may be used.</p>

<p>An LSP page is processed by interpreting all LSP elements, and
sending all non-LSP elements (unless they are extension elements, see
the <a href="advuserguide.html">Advanced User Guide</a>) and all character 
data to the output (subject to <a href="#template">template processing</a>). 
However, some
LSP element (such as <code>lsp:if</code>) can inhibit the output of
parts of the LSP page. Comments and processing instructions in the
LSP page are ignored. Any DTD in the LSP page is not sent to the
output.</p>

<p>To allow high-performance implementation of LSP, an LSP page may be
compiled into some code (for example Java byte code), which can then be
executed several times, possibly with a different set of parameters.
Unless otherwise stated, all processing occurs when the page is
executed.</p>

<p>It's simple to start using LSP in a static HTML (or some XML
based markup language) page. Just add a declaration for the LSP
namespace (<code>xmlns:lsp="http://staldal.nu/LSP/core"</code>) in the
root element and add LSP elements and templates. However, you must
ensure that the HTML page is in well-formed XML format.</p>


<h2>LSP elements</h2>

<p>This section describes all elements in the LSP namespace. An
attribute name in <b>bold</b> means this attribute is required. An
attribute value specification surrounded by curly braces
(<code>{}</code>) means that the attribute value is processed as a <a
href="#template">template</a>.</p>

<h4>lsp:import</h4>

<p class="element-syntax">
<a name="element-import"></a>&lt;lsp:import<br />
&#160;&#160;<b>file</b> = <var>URL</var>&#160;/&gt;
</p>

<p>The <code>lsp:import</code> includes a file when the page is
compiled. Any LSP elements and templates in the included file are
processed.</p>


<h4>lsp:include</h4>

<p class="element-syntax">
<a name="element-include"></a>&lt;lsp:include<br />
&#160;&#160;<b>file</b> = { <var>URL</var> }&#160;/&gt;
</p>

<p>The <code>lsp:include</code> includes a file when the page is
executed. Any elements in the LSP namespace in the included file
are stripped, but their content is keept (this allows the
<code>lsp:root</code> element to be used normally). Any templates in
the included file are not processed.</p>


<h4>lsp:root</h4>

<p class="element-syntax">
<a name="element-root"></a>&lt;lsp:root&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:root&gt;
</p>

<p>The <code>lsp:root</code> element simply outputs all of its content.
Useful as document root element in files to be <code>import</code>ed or
<code>include</code>d. The <code>lsp:root</code> element can be
nested.</p>


<h4>lsp:raw</h4>

<p class="element-syntax">
<a name="element-raw"></a>&lt;lsp:raw&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:raw&gt;
</p>

<p>The <code>lsp:raw</code> element outputs all of its content, without
processing templates in character data or in attribute values on
non-LSP elements. However, templates are still processed in attribute
values on LSP elements. The <code>lsp:raw</code> element can be
nested, nesting has no additional meaning.</p>


<h4>lsp:processing-instruction</h4>

<p class="element-syntax">
<a name="element-processing-instruction"></a>
&lt;lsp:processing-instruction<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> &#160; -(lsp:processing-instruction) --&gt;<br />
&lt;/lsp:processing-instruction&gt;
</p>

<p>The <code>lsp:processing-instruction</code> element creates a
processing instruction in the output. The <code>name</code> attribute
is used as the processing instruction target, and the character data of
the content is used as the processing instruction data.
<code>lsp:processing-instruction</code> may <em>not</em> be nested.</p>


<h4>lsp:if</h4>

<p class="element-syntax">
<a name="element-if"></a>
&lt;lsp:if<br />
&#160;&#160;<b>test</b> = <var>boolean-expression</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:if&gt;
</p>

<p>The <code>test</code> expression is evaluated, and converted to
boolean (as if by a call to the <code>boolean()</code> function).
If the result is true, the content of the <code>lsp:if</code> element
is outputted, otherwise nothing outputted.</p>


<h4>lsp:choose</h4>

<p class="element-syntax">
<a name="element-choose"></a>
&lt;lsp:choose&gt;<br />
&#160;&#160;&lt;!-- Content: (lsp:when+, lsp:otherwise?) --&gt;<br />
&lt;/lsp:choose&gt;
</p>


<h4>lsp:when</h4>

<p class="element-syntax">
<a name="element-when"></a>
&lt;lsp:when<br />
&#160;&#160;<b>test</b> = <var>boolean-expression</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:when&gt;
</p>


<h4>lsp:otherwise</h4>

<p class="element-syntax">
<a name="element-otherwise"></a>
&lt;lsp:otherwise&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:otherwise&gt;
</p>

<p>The <code>test</code> expression for each <code>lsp:when</code> element is
evaluated in turn, and converted to boolean (as if by a call to the <code>boolean()</code> function). The content of the first, and only the first, <code>lsp:when</code> element whose test is true is outputted. If no <code>lsp:when</code> element is true, the content of the <code>lsp:otherwise</code> element is outputted. If no <code>lsp:when</code> element is true and if there is no <code>lsp:otherwise</code> element, nothing is outputted.</p>


<h4>lsp:for-each</h4>

<p class="element-syntax">
<a name="element-for-each"></a>
&lt;lsp:for-each<br />
&#160;&#160;<b>select</b> = <var>list-expression</var><br />
&#160;&#160;<b>var</b> = <var>variable name</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:for-each&gt;
</p>

<p>The <code>select</code> expression is evaulated, and is expected to be of
type list, otherwise an error occurs. The content of the <code>lsp:for-each</code> element
is outputted once for each object in the list, with the variable
specified in the <code>var</code> attribute bound to the current object in
the list. Any variable with the same name in the enclosing scope is
shadowed.</p>


<a name="template"><h2>Templates</h2></a>

<p>All attribute values to non-LSP elements, all character content
(unless contained in an <code>lsp:raw</code> element) and the values of
some attributes to LSP elements are processed as templates. This means
that it may contain LSP expressions surrounded by curly braces
(<code>{}</code>). A such expression is evaluated and the expression
(together with the curly braces) is replaced with its string value. To
actually include a literal curly brace, use a double curly brace.</p>


<h2>LSP Expressions</h2>

<p>The expression language used in LSP is based on <a href="http://www.w3.org/TR/xpath">XPath</a>.
It's essentially XPath without nodesets.</p>

<h3>Basic types</h3>

<p>The expression language has five basic types:</p>

<ul>
<li>boolean (true or false)</li>
<li>number (an IEEE 754 floating-point number)</li>
<li>string (a sequence of UCS characters)</li>
<li>list (an ordered sequence of objects)</li>
<li>tuple (an unordered set of named objects)</li>
</ul>

<p>The boolean, number and string types can be implicitly converted into
each other, as if using the <code>boolean()</code>, <code>number()</code>
and <code>string()</code> functions.</p>

<p>An object can be extracted from a tuple using the '.' notation,
e.g.<br />
<code>$tupleVar.foo</code><br />
or<br />
<code>functionReturningTuple().bar</code><br />
.</p>


<h3>Grammar</h3>
<pre>
Expr ::= OrExpr

PrimaryExpr ::= VariableReference
              | '(' Expr ')'
              | Literal
              | Number
              | FunctionCall

VariableReference ::= '$' LSPName

FunctionCall ::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'

FunctionName ::= LSPName ( ':' LSPName )?  /* not NodeType */

Argument ::= Expr

OrExpr ::= AndExpr
         | OrExpr 'or' AndExpr

AndExpr ::= EqualityExpr
          | AndExpr 'and' EqualiyExpr

EqualityExpr ::= RelationalExpr
               | EqualityExpr '=' RelationalExpr
               | EqualityExpr '!=' RelationalExpr

RelationalExpr ::= AdditiveExpr
                 | RelationalExpr '&lt;' AdditiveExpr
                 | RelationalExpr '>' AdditiveExpr
                 | RelationalExpr '&lt;=' AdditiveExpr
                 | RelationalExpr '>=' AdditiveExpr

AdditiveExpr ::= MultiplicativeExpr
               | AdditiveExpr '+' MultiplicativeExpr
               | AdditiveExpr '-' MultiplicativeExpr

MultiplicativeExpr ::= UnaryExpr
                     | MultiplicativeExpr '*' UnaryExpr
                     | MultiplicativeExpr 'div' UnaryExpr
                     | MultiplicativeExpr 'mod' UnaryExpr

UnaryExpr ::= TupleExpr
            | '-' UnaryExpr

TupleExpr ::= PrimaryExpr
            | TupleExpr '.' LSPName
</pre>

<h3>Lexical</h3>

<pre>
LSPName ::= NCName not containing any '.'

Literal ::= '"' [^"]* '"'
          | "'" [^']* "'"

Number ::= Digits ('.' Digits?)?
         | '.' Digits


NodeType ::= 'comment'
           | 'text'
           | 'processing-instruction'
           | 'node'

Digits ::= [0-9]+
</pre>

<h3>Functions</h3>

<p>Non-namespaced functions are the core functions, defined as in <a href="http://www.w3.org/TR/xpath">XPath</a>:</p>

<ul>
<li>string string(object)</li>
<li>string concat(string, string, string*)</li>
<li>boolean starts-with(string, string)</li>
<li>boolean contains(string, string)</li>
<li>string substring-before(string, string)</li>
<li>string substring-after(string, string)</li>
<li>string substring(string, string, number?)</li>
<li>number string-length(string)</li>
<li>string normalize-space(string)</li>
<li>string translate(string, string, string)</li>
</ul>
<ul>
<li>boolean boolean(object)</li>
<li>boolean not(boolean)</li>
<li>boolean true()</li>
<li>boolean false()</li>
</ul>
<ul>
<li>number number(object)</li>
<li>number floor(number)</li>
<li>number ceiling(number)</li>
<li>number round(number)</li>
</ul>
<ul>
<li>number count(list) - the number of objects in the list</li>
</ul>

<p>Namespaced functions are extension functions, see the <a
href="advuserguide.html">Advanced User Guide</a></p>

<h3>Variables</h3>

<p>Unlike XPath, variable name may not be namespaced.</p>

<p>The parameters passed to the LSP page are bound to variables as
strings in the outermost scope.</p>

<p>Attempting to reference an unbound variable gives the empty string
(which may be implicitly converted to the boolean value <code>false</code>
or to the number <code>NaN</code>).</p>

</body>
</html>

