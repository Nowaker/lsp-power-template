<?xml version="1.0" encoding="iso-8859-1"?>
<html>
<head><title>LSP User Guide</title></head>
<link rel="stylesheet" type="text/css" href="manual.css" />
<body>
<h1>LSP User Guide</h1>

<h2>Overview</h2>

<p>LSP is an advanced web template language based on XML technology. 
LSP provides powerful and easy to use presentation logic, but keeps 
bussines logic and technical details out of templates. LSP is compiled 
into Java bytecode for efficient execution.</p>

<p>LSP is fully based on XML and namespaces. This means that it's easy
to efficiently use LSP together with other XML technologies, such as
XSLT (for example, you can process the output of LSP with XSLT).</p>

<p>LSP can be used as an alternative to JSP in a 
<a target="_new" href="http://java.sun.com/products/servlet">Java Servlet</a> 
based web application. See <a href="lsp-servlet.html">here</a>.</p>

<h2>System requirements</h2>

<p>LSP requires Java Runtime Environment (JRE) version 1.4 or 1.5 
(also known as 5.0).</p>

<h2>LSP basics</h2>

<p>An LSP page is a well-formed XML document, composed of elements from
the LSP namespace and from other namespaces (including the null
namespace). The document root element may, but doesn't have to, be in
the LSP namespace.</p>

<p>The namespace URI for LSP is
<code>http://staldal.nu/LSP/core</code>. In this document, it's assumed
that this namespace is mapped to the prefix <code>lsp</code>, however
any prefix may be used.</p>

<p>An LSP page is processed by interpreting all LSP elements, and
sending all non-LSP elements (unless they are <a href="#extlib">extension elements</a>), 
all character data and all processing instructions to the output 
(subject to <a href="#template">template processing</a>). 
However, some LSP element can alter the output of parts of the LSP page. 
Comments in the LSP page are ignored. Any DTD in the LSP page is not sent 
to the output.</p>

<p>To ensure high performance, LSP pages are compiled into bytecode, 
which can then be executed several times, possibly with a different set 
of parameters. Unless otherwise stated, all processing occurs when the page 
is executed.</p>

<p>It's simple to start using LSP in a static HTML (or some XML
based markup language) page. Just add a declaration for the LSP
namespace (<code>xmlns:lsp="http://staldal.nu/LSP/core"</code>) in the
root element and add LSP elements. However, you must
ensure that the HTML page is in well-formed XML format.</p>


<h2>LSP elements</h2>

<p>This section describes all elements in the LSP namespace. An
attribute name in <b>bold</b> means this attribute is required. An
attribute value specification surrounded by curly braces
(<code>{}</code>) means that the attribute value is processed as a <a
href="#template">template</a>.</p>

<p>In elements marked with <code>(whitespace stripping)</code>,
any whitespace node immediatly after the start-tag and before 
the end-tag is stripped. This stripping can be inhibited by setting
the <code>xml:space</code> attribute to <code>preserve</code>. 
The prupose of this whitespace stripping is to make it possible to
format the LSP source in a readable way without getting a lot of unnessecary 
whitespace in the output.</p>

<h4>lsp:output</h4>

<p class="element-syntax">
<a name="element-output"></a>&lt;lsp:output<br />
&#160;&#160;method = "xml" | "html" | "xhtml" | "text"<br />
&#160;&#160;version = <var>nmtoken</var><br />
&#160;&#160;encoding = <var>string</var><br />
&#160;&#160;omit-xml-declaration = "yes" | "no"<br />
&#160;&#160;standalone = "yes" | "no"<br />
&#160;&#160;doctype-public = <var>string</var><br />
&#160;&#160;doctype-system = <var>string</var><br />
&#160;&#160;indent = "yes" | "no"<br />
&#160;&#160;media-type = <var>string</var>&#160;<br />
&#160;&#160;stylesheet = <var>string</var>&#160;/&gt;
</p>

<p>The <code>lsp:output</code> specifies how the LSP page should be 
serialized to a byte stream. The parameters has the same meaning as in 
<a href="http://www.w3.org/TR/xslt#output">XSLT 1.0</a>, with the addition of the 
<code>xhtml</code> output method. The <code>xhtml</code> 
output method works as the <code>xml</code> output method, but uses the applicable
HTML compatibility guidelines published in 
<a href="http://www.w3.org/TR/xhtml1/#guidelines">Appendix C of the XHTML 1.0 
specification</a>.</p>

<p>An LSP page may contain at most one <code>lsp:output</code> element.</p>

<p>Any whitespace immediately before an <code>lsp:output</code> element 
will be stripped, unless the <code>xml:space</code> attribute is set to <code>preserve</code>.</p>

<p>If an LSP page contains no <code>lsp:output</code> element with a 
<code>method</code> parameter, the output method is choosen as follows at
compile time:</p>
<ul>
<li>If the root element is <code>html</code> (in any case) with 
null namespace URI, the output method is <code>html</code>.</li>

<li>If the root element is <code>html</code> (in lower case) with 
namespace URI <code>http://www.w3.org/1999/xhtml</code>,
the output method is <code>html</code> or <code>xhtml</code> depending
on the "xhtml" parameter to the LSP compiler.</li>

<li>In all other cases, the output method is <code>xml</code>.</li>

</ul>

<p>If the <code>stylesheet</code> parameter is specified, an XSLT stylesheet is used 
to transform the output of the LSP page. All other output parameters are
ignored and the output parameters in the XSLT stylesheet are used instead.
Note that XSLT might use an other algorithm to determine default output 
method, so be sure to always specify output method in the XSLT stylesheet 
explicitly.</p> 


<h4>lsp:import</h4>

<p class="element-syntax">
<a name="element-import"></a>&lt;lsp:import<br />
&#160;&#160;<b>file</b> = <var>URL</var>&#160;/&gt;
</p>

<p>The <code>lsp:import</code> includes a file when the page is
compiled. Any LSP elements and templates in the included file are
processed.</p>


<h4>lsp:root</h4>

<p class="element-syntax">
<a name="element-root"></a>&lt;lsp:root&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:root&gt;
</p>

<p>The <code>lsp:root</code> element simply outputs all of its content.
Useful as document root element in files to be <code>import</code>ed. 
The <code>lsp:root</code> element can be nested.</p>


<h4>lsp:processing-instruction</h4>

<p class="element-syntax">
<a name="element-processing-instruction"></a>
&lt;lsp:processing-instruction<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> &#160; -(lsp:processing-instruction, lsp:element, lsp:attribute) --&gt;<br />
&lt;/lsp:processing-instruction&gt;
</p>

<p>The <code>lsp:processing-instruction</code> element creates a
processing instruction in the output. The <code>name</code> attribute
is used as the processing instruction target, and the character data of
the content is used as the processing instruction data.
<code>lsp:processing-instruction</code> may <em>not</em> be nested.</p>


<h4>lsp:element</h4>

<p class="element-syntax">
<a name="element-element"></a>
&lt;lsp:element<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
&#160;&#160;namespace = { <var>URI</var> }&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:element&gt;
</p>

<p>The <code>lsp:element</code> element creates an
element with a computed name in the output. The <code>name</code> attribute
is used as the local name of the element. The <code>namespace</code> attribute
is used as the namespace URI of the element (if omitted, the generated element
will be in the default namespace in effect, set <code>namespace</code> 
attribute to the empty string to explicitly place the element in the null 
namespace).</p>

<p><em>Note:</em> unlike the similar element in 
XSLT, the value of the <code>name</code> attribute may not be a QName.</p>


<h4>lsp:attribute</h4>

<p class="element-syntax">
<a name="element-attribute"></a>
&lt;lsp:attribute<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
&#160;&#160;namespace = { <var>URI</var> }<br />
&#160;&#160;<b>value</b> = { <var>any</var> }/&gt;
</p>

<p>The <code>lsp:attribute</code> element creates an attribute with a 
computed name in the output. The attribute is attached to the enclosing 
element (which may be either an <code>lsp:element</code> or a normal literal element).
The <code>name</code> attribute is used as the local name of the attribute. The <code>namespace</code> attribute
is used as the namespace URI of the atribute (if omitted, the created attribute
will be in the null namespace). May not be used to create namespace 
declarations, the value of the <code>name</code> attribute may not be "<code>xmlns</code>".
It's an error to add an attribute with the same name as an already 
existing attribute, this error cannot be detected at compile time, and will 
result in undefined behaviour at runtime. If the <code>name</code> 
expression evaluates to the empty string, no attribute will be created.</p>

<p>Any whitespace immediately before an <code>lsp:attribute</code> element,
and any whitespace immediately after an <code>lsp:attribute</code> element 
if there are no more children of the parent element, will be stripped. 
Unless the <code>xml:space</code> attribute is set to <code>preserve</code>.</p>

<p><em>Note:</em> unlike the similar element in XSLT, the value of the 
<code>name</code> attribute may not be a QName.</p>


<h4>lsp:value-of</h4>

<p class="element-syntax">
<a name="element-value-of"></a>
&lt;lsp:value-of<br />
&#160;&#160;<b>select</b> = <var>string-expression</var><br />
&#160;&#160;disable-output-escaping = <var>boolean</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:value-of&gt;
</p>

<p>The <code>select</code> expression is evaluated, and converted to
string (as if by a call to the <code>string()</code> function).
That string is outputted. Any content of the <code>lsp:value-of</code> 
element is ignored (may be used as sample data during development).</p>

<p>If the <code>disable-output-escaping</code> attribute is specified and 
set to "yes" or "disable-output-escaping", the noraml escaping of 
characters &amp;, &lt; and characters not possible in the current character 
encoding is disabled. This allows you to e.g. include a XML or HTML fragment 
as a string. <em>Note:</em> This may cause the output to be ill-formed.</p>


<h4>lsp:if</h4>

<p class="element-syntax">
<a name="element-if"></a>
&lt;lsp:if<br />
&#160;&#160;<b>test</b> = <var>boolean-expression</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any (whitespace stripping)</var> --&gt;<br />
&lt;/lsp:if&gt;
</p>

<p>The <code>test</code> expression is evaluated, and converted to
boolean (as if by a call to the <code>boolean()</code> function).
If the result is true, the content of the <code>lsp:if</code> element
is outputted, otherwise nothing outputted.</p>


<h4>lsp:choose</h4>

<p class="element-syntax">
<a name="element-choose"></a>
&lt;lsp:choose&gt;<br />
&#160;&#160;&lt;!-- Content: (lsp:when+, lsp:otherwise?) --&gt;<br />
&lt;/lsp:choose&gt;
</p>


<h4>lsp:when</h4>

<p class="element-syntax">
<a name="element-when"></a>
&lt;lsp:when<br />
&#160;&#160;<b>test</b> = <var>boolean-expression</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any (whitespace stripping)</var> --&gt;<br />
&lt;/lsp:when&gt;
</p>


<h4>lsp:otherwise</h4>

<p class="element-syntax">
<a name="element-otherwise"></a>
&lt;lsp:otherwise&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any (whitespace stripping)</var> --&gt;<br />
&lt;/lsp:otherwise&gt;
</p>

<p>The <code>test</code> expression for each <code>lsp:when</code> element is
evaluated in turn, and converted to boolean (as if by a call to the <code>boolean()</code> function). The content of the first, and only the first, <code>lsp:when</code> element whose test is true is outputted. If no <code>lsp:when</code> element is true, the content of the <code>lsp:otherwise</code> element is outputted. If no <code>lsp:when</code> element is true and if there is no <code>lsp:otherwise</code> element, nothing is outputted.</p>


<h4>lsp:for-each</h4>

<p class="element-syntax">
<a name="element-for-each"></a>
&lt;lsp:for-each<br />
&#160;&#160;<b>select</b> = <var>list-expression</var><br />
&#160;&#160;<b>var</b> = <var>variable name</var>&gt;<br />
&#160;&#160;status = <var>variable name</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any (whitespace stripping)</var> --&gt;<br />
&lt;/lsp:for-each&gt;
</p>

<p>The <code>select</code> expression is evaulated, and is expected to be of
type list, otherwise an error occurs. The content of the <code>lsp:for-each</code> element
is outputted once for each object in the list, with the variable
specified in the <code>var</code> attribute bound to the current object in
the list. If the <code>status</code> attribute is specified, a variable with 
that name is bound to an interator status object. Any variable with the 
same name in the enclosing scope is shadowed.</p>

<p>An iterator status object is a tuple with the following elements:
<ul>
<li><code>index</code> - a number the position in the list, starting from 1</li>
<li><code>first</code> - a boolean indicating if this is the first element</li>
<li><code>last</code> - a boolean indicating if this is the last element</li>
<li><code>even</code> - a boolean indicating if this is an even element</li>
<li><code>odd</code> - a boolean indicating if this is an odd element</li>
</ul>
</p>

<h4>lsp:let</h4>

<p class="element-syntax">
<a name="element-let"></a>
&lt;lsp:let<br />
&#160;&#160;<i>var1</i> = <var>expression</var><br />
&#160;&#160;<i>var2</i> = <var>expression</var><br />
&#160;&#160;<i>...</i><br />
&#160;&#160;<i>varn</i> = <var>expression</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any (whitespace stripping)</var> --&gt;<br />
&lt;/lsp:let&gt;
</p>

<p>Each expression is evaulated, and the value is bound to a variable with the 
same name as the attribute within the body of the <code>lsp:let</code> element.
Any variables with the same name in the enclosing scope are shadowed.</p>


<a name="template"><h2>Templates</h2></a>

<p>All attribute values to non-LSP elements and the values of
some attributes to LSP elements are processed as templates. This means
that it may contain LSP expressions surrounded by curly braces
(<code>{}</code>). A such expression is evaluated and the expression
(together with the curly braces) is replaced with its string value. To
actually include a literal curly brace, use a double curly brace.</p>

<p>If the attribute value of an non-LSP element consists of an expression 
yeilding a boolean value, it will be handled specially. If the expression
evaulates to false the attribute will be removed, if the expression evaulates 
to true the attribute will get its name as value. This is useful for handling
the boolean attributes in HTML, such as <code>checked</code> and 
<code>selected</code>. <em>Note:</em> the check if the expression yeilds a 
boolean value is done at compile time, it won't work if the expression is a
variable reference, a tuple expression or an <a href="#extlib">extension function</a> call. Wrap
the expression with the <code>boolean</code> function to force handling as
a boolean. Wrap the expression with the <code>string</code> function to 
inhibit handling as a boolean.</p>

<p>Example:</p>
<pre>
&lt;select&gt;
  &lt;lsp:for-each select="$theList" var="ent"&gt;
    &lt;option value="{$ent.value}" selected="{$ent.value=$currentVal}"&gt;
      &lt;lsp:value-of select="$ent.text"/&gt;
    &lt;/option&gt;
  &lt;/lsp:for-each&gt;
&lt;/select&gt;

</pre>
 

<h2>LSP Expressions</h2>

<p>The expression language used in LSP is based on <a href="http://www.w3.org/TR/xpath">XPath</a>.
It's essentially XPath 1.0 without nodesets, with the conditional expression "if ... then ... else ..." from XPath 2.0.</p>

<h3>Types</h3>

<p>The expression language has five types:</p>

<ul>
<li>boolean (true or false)</li>
<li>number (an IEEE 754 floating-point number)</li>
<li>string (a sequence of UCS characters)</li>
<li>list (an ordered sequence of objects)</li>
<li>tuple (an unordered set of named objects)</li>
</ul>

<p>The boolean, number and string types can be implicitly converted into
each other, as if using the <code>boolean()</code>, <code>number()</code>
and <code>string()</code> functions. A list can be implicitly converted into 
boolean, the result will be <code>true</code> if the list has at least one element.</p>

<p>An object can be extracted from a tuple either by appending an '.' and a 
symbol, e.g.<br />
<code>$tupleVar.foo</code><br />
or<br />
<code>functionReturningTuple().bar</code><br />
. Or by appending '[]' with an expression, e.g.<br /> 
<code>$tupleVar[$myKey]</code><br />
or<br />
<code>functionReturningTuple()[getKey()]</code><br />
.</p>
<p>With the '[]' notation, a tuple can be used like an hashtable, and is 
most likley implemented with an hashtable. Note that the value will be 
converted to a string before used as key for lookup, this means that a 
mapping with another type of key will not be found by LSP (e.g. you cannot 
use a Java Number).</p>


<h3>Grammar</h3>
<pre>
Expr ::= OrExpr

PrimaryExpr ::= VariableReference
              | '(' Expr ')'
              | Literal
              | Number
              | FunctionCall

VariableReference ::= '$' LSPName

FunctionCall ::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'

FunctionName ::= LSPName ( ':' LSPName )?  /* not NodeType */

Argument ::= Expr

OrExpr ::= AndExpr
         | OrExpr 'or' AndExpr

AndExpr ::= IfExpr
          | AndExpr 'and' IfExpr

IfExpr ::= EqualityExpr
         | 'if' '(' Expr ')' 'then' Expr 'else' EqualityExpr 

EqualityExpr ::= RelationalExpr
               | EqualityExpr '=' RelationalExpr
               | EqualityExpr '!=' RelationalExpr

RelationalExpr ::= AdditiveExpr
                 | RelationalExpr '&lt;' AdditiveExpr
                 | RelationalExpr '>' AdditiveExpr
                 | RelationalExpr '&lt;=' AdditiveExpr
                 | RelationalExpr '>=' AdditiveExpr

AdditiveExpr ::= MultiplicativeExpr
               | AdditiveExpr '+' MultiplicativeExpr
               | AdditiveExpr '-' MultiplicativeExpr

MultiplicativeExpr ::= UnaryExpr
                     | MultiplicativeExpr '*' UnaryExpr
                     | MultiplicativeExpr 'div' UnaryExpr
                     | MultiplicativeExpr 'mod' UnaryExpr

UnaryExpr ::= TupleExpr
            | '-' UnaryExpr

TupleExpr ::= PrimaryExpr
            | TupleExpr '.' LSPName
            | TupleExpr '[' Expr ']'
</pre>

<h3>Lexical</h3>

<pre>
LSPName ::= NCName not containing any '.'

Literal ::= '"' [^"]* '"'
          | "'" [^']* "'"

Number ::= Digits ('.' Digits?)?
         | '.' Digits


NodeType ::= 'comment'
           | 'text'
           | 'processing-instruction'
           | 'node'

Digits ::= [0-9]+
</pre>

<h3>Functions</h3>

<p>Non-namespaced functions are the core functions, defined as in <a href="http://www.w3.org/TR/xpath">XPath</a>:</p>

<ul>
<li>string string(object)</li>
<li>string concat(string, string, string*)</li>
<li>boolean starts-with(string, string)</li>
<li>boolean contains(string, string)</li>
<li>string substring-before(string, string)</li>
<li>string substring-after(string, string)</li>
<li>string substring(string, string, number?)</li>
<li>number string-length(string)</li>
<li>string normalize-space(string)</li>
<li>string translate(string, string, string)</li>
</ul>
<ul>
<li>boolean boolean(object)</li>
<li>boolean not(boolean)</li>
<li>boolean true()</li>
<li>boolean false()</li>
</ul>
<ul>
<li>number number(object)</li>
<li>number floor(number)</li>
<li>number ceiling(number)</li>
<li>number round(number)</li>
</ul>
<ul>
<li>number count(list) - the number of objects in the list</li>
<li>list seq(start, end, step?) - generate a list of numbers with the
specified sequence</li>
</ul>

<p>Namespaced functions are <a href="#extlib">extension functions</a>.</p>


<h3>Variables</h3>

<p>Unlike XPath, variable name may not be namespaced.</p>

<p>The parameters passed to the LSP page are bound to variables 
in the outermost scope.</p>

<p>It's an error to attempt to reference an unbound variable.</p>


<h2>The LSP compiler</h2>

<p>LSP comes with a compiler which compiles LSP pages into Java 
<code>.class</code> files. The LSP compiler is contained in <code>lspc.jar</code>.</p>

<p>For a programmatic Java interface to the LSP compiler, look at the 
<a href="javadoc/nu/staldal/lsp/compiler/package-summary.html"><code>nu.staldal.lsp.compiler</code></a> package.</p>

<p>The LSP compiler uses the third-party library <a href="http://jakarta.apache.org/bcel/">BCEL</a>.
The BCEL library is only needed when compiling LSP pages, not when 
executing the compiled code. <code>lsprt.jar</code> is also needed by the compiler.</p>


<h3>Running LSP compiler from command line</h3>

<p>The LSP compiler is invoked by the application class
<code>nu.staldal.lsp.compiler.LSPCompilerCLI</code>. The syntax is:</p>
<pre>
lspc [-verbose] [-force] [-xhtml] [-sourcepath <em>sourcepath</em>] [-d <em>destdir</em>] <em>inputFile</em> ...
</pre>

<p><em>sourcepath</em> specifies where to look for imported files with 
relative URL:s, may contain multiple directories separated by ';' (will 
search the directory where the source file is as well).
<em>destdir</em> specifies where place generated files, default is current directory.
Multiple input files can be specified. If <code>-force</code> is not specified, 
files are only compiled if the source file is newer than the target file 
(imported files are also checked, changing an imported file will trigger 
recompile). If <code>-xhtml</code> is specified, 
the default output method for XHTML pages will be <code>xhtml</code>, 
otherwise it will be <code>html</code>.</p> 

<p>You have to put <code>bcel.jar</code> and <code>lsprt.jar</code> in CLASSPATH. 
If you use any <a href="extlib">extension libraries</a>, you have to include them in the CLASSPATH as well.</p>


<h3>Using LSP compiler from within Apache Ant</h3>

<p>Define the LSP compiler Ant task in the Ant
build file like this:</p>
<pre>
&lt;taskdef name="lspc" classname="nu.staldal.lsp.compiler.LSPCompilerAntTask"&gt;
  &lt;classpath&gt;
    &lt;pathelement location="<em>locationOfLSPJars</em>/lspc.jar" /&gt;
    &lt;pathelement location="<em>locationOfLSPJars</em>/lsprt.jar" /&gt;
    &lt;pathelement location="<em>locationOfBCELJars</em>/bcel.jar" /&gt;
  &lt;/classpath&gt;
&lt;/taskdef&gt;  
</pre>

<p>If you use any <a href="#extlib">extension libraries</a>, you have to include them in the 
classpath as well.</p>

<p>and use the following syntax:</p>
<pre>
&lt;lspc sourcepath="<em>sourcepath</em>"
         <b>destdir</b>="<em>where to place compiled code</em>"
         force="<em>force recompiling of all files</em>"&gt;
         xhtml="<em>use xhtml as default output method</em>"&gt;
      &lt;fileset dir="lsp"&gt;
        &lt;include name="*.lsp" /&gt;
      &lt;/fileset&gt;
&lt;/lspc&gt;
</pre>

<p><em>sourcepath</em> specifies where to look for imported files with 
relative URL:s, may contain multiple directories separated by ';' or ':' 
(will search the directory where the source file is as well).
If <code>force</code> is not set, files are only compiled if 
the source file is newer than the target file (imported files are also checked, 
changing an imported file will trigger recompile). If <code>xhtml</code> is set, 
the default output method for XHTML pages will be <code>xhtml</code>, 
otherwise it will be <code>html</code>.</p>


<h2>The LSP runtime</h2>

<p>The LSP runtime is contained in <code>lsprt.jar</code>.</p>

<p>For a general Java interface to the LSP runtime, look at the 
<a href="javadoc/nu/staldal/lsp/package-summary.html"><code>nu.staldal.lsp</code></a> 
package, especially the <code>LSPHelper</code> class.</p>

<p>For a Java Servlet interface to the LSP runtime, look at the 
<a href="javadoc/nu/staldal/lsp/servlet/package-summary.html"><code>nu.staldal.lsp.servlet</code></a> 
package. A <a href="lsp-servlet.html">description</a> how to setup LSP for use with Java Servlets.
Extension libraries will get an <a href="javadoc/nu/staldal/lsp/servlet/LSPServletContext.html"><code>nu.staldal.lsp.servlet.LSPServletContext</code></a> 
(containing the <code>javax.servlet.ServletContext</code>, the <code>javax.servlet.http.HttpServletRequest</code> 
and the <code>javax.servlet.http.HttpServletResponse</code>) 
as external context.</p>

<h2><a name="extlib">Extension libraries</a></h2>

<p>Extension function and extension elements are implemented in Java with 
extension libraries. An extension library is a Java class implementing 
the <a href="javadoc/nu/staldal/lsp/LSPExtLib.html"><code>nu.staldal.lsp.LSPExtLib</code></a> 
interface.</p>

<p>Choose an namespace URL for your extension library, and plug it in to LSP by
making a file <code>/nu/staldal/lsp/extlib/<em>encodedURL</em></code>
visible in the CLASSPATH. That file should contain the fully qualified class
name of your implementation.</p>

<p>The URL is encoded by doing the following replacements:</p>
<ul>
<li>- =&gt; --</li>
<li>$ =&gt; $$</li>
<li>~ =&gt; ~~</li>

<li>/ =&gt; -</li>
<li>? =&gt; $</li>
<li>: =&gt; ~</li>
</ul>

<p>This encoding is performed by the method <code>nu.staldal.lsp.Utils.encodePath(String)</code>.</p>

<p>E.g. <code>http://acme.com/TheExtLib</code> =&gt; <code>http~--acme.com-TheExtLib</code></p> 
  
<p>The extension library must be available to both compiler and runtime.</p>

</body>
</html>

