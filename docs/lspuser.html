<?xml version="1.0" encoding="iso-8859-1"?>
<html>
<head><title>LSP User Guide</title></head>
<link rel="stylesheet" type="text/css" href="manual.css" />
<body>
<h1>LSP User Guide</h1>

<h2>Overview</h2>

<p>LSP is a technology for pseudo-dynamic content processing.</p>

<p>The design of LSP is inspired by dynamic content technologies,
especially JSP, and by XML technologies, especially XSLT.</p>

<p>LSP is fully based on XML and namespaces. This means that it's easy
to efficiently use LSP together with other XML technologies, such as
XSLT (for example, an LSP page can be constructed with XSLT, and you
can process the output of LSP with XSLT).</p>


<h2>LSP basics</h2>

<p>An LSP page is a well-formed XML document, composed of elements from
the LSP namespace and from other namespaces (including the null
namespace). The document root element may, but doesn't have to, be in
the LSP namespace.</p>

<p>The namespace URI for LSP is
<code>http://staldal.nu/LSP/core</code>. In this document, it's assumed
that this namespace is mapped to the prefix <code>lsp</code>, however
any prefix may be used.</p>

<p>An LSP page is processed by interpreting all LSP elements, and
sending all non-LSP elements (unless they are extension elements, see
the <a href="advuserguide.html">Advanced User Guide</a>), all character 
data and all processing instructions to the output 
(subject to <a href="#template">template processing</a>). 
However, some LSP element can alter the output of parts of the LSP page. 
Comments in the LSP page are ignored. Any DTD in the LSP page is not sent 
to the output.</p>

<p>To ensure high performance, LSP pages are compiled into some code which 
is more efficient to interpret than the XML source format, 
which can then be executed several times, possibly with a different set 
of parameters. Unless otherwise stated, all processing occurs when the page is
executed.</p>

<p>It's simple to start using LSP in a static HTML (or some XML
based markup language) page. Just add a declaration for the LSP
namespace (<code>xmlns:lsp="http://staldal.nu/LSP/core"</code>) in the
root element and add LSP elements. However, you must
ensure that the HTML page is in well-formed XML format.</p>


<h2>LSP elements</h2>

<p>This section describes all elements in the LSP namespace. An
attribute name in <b>bold</b> means this attribute is required. An
attribute value specification surrounded by curly braces
(<code>{}</code>) means that the attribute value is processed as a <a
href="#template">template</a>.</p>

<h4>lsp:import</h4>

<p class="element-syntax">
<a name="element-import"></a>&lt;lsp:import<br />
&#160;&#160;<b>file</b> = <var>URL</var>&#160;/&gt;
</p>

<p>The <code>lsp:import</code> includes a file when the page is
compiled. Any LSP elements and templates in the included file are
processed.</p>


<h4>lsp:include</h4>

<p class="element-syntax">
<a name="element-include"></a>&lt;lsp:include<br />
&#160;&#160;<b>file</b> = { <var>URL</var> }&#160;/&gt;
</p>

<p>The <code>lsp:include</code> includes a file when the page is
executed. Any elements in the LSP namespace in the included file
are stripped, but their content is keept (this allows the
<code>lsp:root</code> element to be used normally). Any templates in
the included file are not processed.</p>


<h4>lsp:root</h4>

<p class="element-syntax">
<a name="element-root"></a>&lt;lsp:root&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:root&gt;
</p>

<p>The <code>lsp:root</code> element simply outputs all of its content.
Useful as document root element in files to be <code>import</code>ed or
<code>include</code>d. The <code>lsp:root</code> element can be
nested.</p>


<h4>lsp:processing-instruction</h4>

<p class="element-syntax">
<a name="element-processing-instruction"></a>
&lt;lsp:processing-instruction<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> &#160; -(lsp:processing-instruction, lsp:element, lsp:attribute) --&gt;<br />
&lt;/lsp:processing-instruction&gt;
</p>

<p>The <code>lsp:processing-instruction</code> element creates a
processing instruction in the output. The <code>name</code> attribute
is used as the processing instruction target, and the character data of
the content is used as the processing instruction data.
<code>lsp:processing-instruction</code> may <em>not</em> be nested.</p>


<h4>lsp:element</h4>

<p class="element-syntax">
<a name="element-element"></a>
&lt;lsp:element<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
&#160;&#160;namespace = { <var>URI</var> }&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:element&gt;
</p>

<p>The <code>lsp:element</code> element creates an
element with a computed name in the output. The <code>name</code> attribute
is used as the local name of the element. The <code>namespace</code> attribute
is used as the namespace URI of the element (if omitted, the generated element
will be in the default namespace in effect, set <code>namespace</code> 
attribute to the empty string to explicitly place the element in the null 
namespace).</p>

<p><em>Note:</em> unlike the similar element in 
XSLT, the value of the <code>name</code> attribute may not be a QName.</p>


<h4>lsp:attribute</h4>

<p class="element-syntax">
<a name="element-attribute"></a>
&lt;lsp:attribute<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
&#160;&#160;namespace = { <var>URI</var> }<br />
&#160;&#160;<b>value</b> = { <var>any</var> }/&gt;
</p>

<p>The <code>lsp:attribute</code> element creates an attribute with a 
computed name in the output. The attribute is attached to the enclosing 
element (which may be either an <code>lsp:element</code> or a normal literal element).
The <code>name</code> attribute is used as the local name of the attribute. The <code>namespace</code> attribute
is used as the namespace URI of the atribute (if omitted, the created attribute
will be in the null namespace). May not be used to create namespace 
declarations, the value of the <code>name</code> attribute may not be "<code>xmlns</code>".
It's an error to add an attribute with the same name as an already 
existing attribute, this error cannot be detected at compile time, and will 
result in undefined behaviour at runtime. If the <code>name</code> 
expression evaluates to the empty string, no attribute will be created.</p>

<p>Note that it's not possible to nest an <code>lsp:attribute</code> element
inside <code>lsp:if</code> or <code>lsp:choose</code>. To conditionally add 
an attribute, use the <code>if ... then ... else ...</code> expression and
the fact that <code>lsp:attribute</code> will not add any attribute if 
<code>name</code> is the empty string. E.g.</p>

<pre>
&lt;option value="4711"&gt;
&lt;lsp:attribute name="{if (cond) then 'selected' else ''}" value="selected"/&gt;
foo&lt;/option&gt;
</pre>

<p><em>Note:</em> unlike the similar element in XSLT, the value of the 
<code>name</code> attribute may not be a QName.</p>


<h4>lsp:value-of</h4>

<p class="element-syntax">
<a name="element-value-of"></a>
&lt;lsp:value-of<br />
&#160;&#160;<b>select</b> = <var>string-expression</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:value-of&gt;
</p>

<p>The <code>select</code> expression is evaluated, and converted to
string (as if by a call to the <code>string()</code> function).
That string is outputted. Any content of the <code>lsp:value-of</code> 
element is ignored (may be used as sample data during development).</p>


<h4>lsp:if</h4>

<p class="element-syntax">
<a name="element-if"></a>
&lt;lsp:if<br />
&#160;&#160;<b>test</b> = <var>boolean-expression</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:if&gt;
</p>

<p>The <code>test</code> expression is evaluated, and converted to
boolean (as if by a call to the <code>boolean()</code> function).
If the result is true, the content of the <code>lsp:if</code> element
is outputted, otherwise nothing outputted.</p>


<h4>lsp:choose</h4>

<p class="element-syntax">
<a name="element-choose"></a>
&lt;lsp:choose&gt;<br />
&#160;&#160;&lt;!-- Content: (lsp:when+, lsp:otherwise?) --&gt;<br />
&lt;/lsp:choose&gt;
</p>


<h4>lsp:when</h4>

<p class="element-syntax">
<a name="element-when"></a>
&lt;lsp:when<br />
&#160;&#160;<b>test</b> = <var>boolean-expression</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:when&gt;
</p>


<h4>lsp:otherwise</h4>

<p class="element-syntax">
<a name="element-otherwise"></a>
&lt;lsp:otherwise&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:otherwise&gt;
</p>

<p>The <code>test</code> expression for each <code>lsp:when</code> element is
evaluated in turn, and converted to boolean (as if by a call to the <code>boolean()</code> function). The content of the first, and only the first, <code>lsp:when</code> element whose test is true is outputted. If no <code>lsp:when</code> element is true, the content of the <code>lsp:otherwise</code> element is outputted. If no <code>lsp:when</code> element is true and if there is no <code>lsp:otherwise</code> element, nothing is outputted.</p>


<h4>lsp:for-each</h4>

<p class="element-syntax">
<a name="element-for-each"></a>
&lt;lsp:for-each<br />
&#160;&#160;<b>select</b> = <var>list-expression</var><br />
&#160;&#160;<b>var</b> = <var>variable name</var>&gt;<br />
&#160;&#160;status = <var>variable name</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:for-each&gt;
</p>

<p>The <code>select</code> expression is evaulated, and is expected to be of
type list, otherwise an error occurs. The content of the <code>lsp:for-each</code> element
is outputted once for each object in the list, with the variable
specified in the <code>var</code> attribute bound to the current object in
the list. If the <code>status</code> attribute is specified, a variable with 
that name is bound to an interator status object. Any variable with the 
same name in the enclosing scope is shadowed.</p>

<p>An iterator status object is a tuple with the following elements:
<ul>
<li><code>index</code> - a number the position in the list, starting from 1</li>
<li><code>first</code> - a boolean indicating if this is the first element</li>
<li><code>last</code> - a boolean indicating if this is the last element</li>
<li><code>even</code> - a boolean indicating if this is an even element</li>
<li><code>odd</code> - a boolean indicating if this is an odd element</li>
</ul>
</p>

<h4>lsp:let</h4>

<p class="element-syntax">
<a name="element-let"></a>
&lt;lsp:let<br />
&#160;&#160;<i>var1</i> = <var>expression</var><br />
&#160;&#160;<i>var2</i> = <var>expression</var><br />
&#160;&#160;<i>...</i><br />
&#160;&#160;<i>varn</i> = <var>expression</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:let&gt;
</p>

<p>Each expression is evaulated, and the value is bound to a variable with the 
same name as the attribute within the body of the <code>lsp:let</code> element.
Any variables with the same name in the enclosing scope are shadowed.</p>


<a name="template"><h2>Templates</h2></a>

<p>All attribute values to non-LSP elements and the values of
some attributes to LSP elements are processed as templates. This means
that it may contain LSP expressions surrounded by curly braces
(<code>{}</code>). A such expression is evaluated and the expression
(together with the curly braces) is replaced with its string value. To
actually include a literal curly brace, use a double curly brace.</p>


<h2>LSP Expressions</h2>

<p>The expression language used in LSP is based on <a href="http://www.w3.org/TR/xpath">XPath</a>.
It's essentially XPath 1.0 without nodesets, with the conditional expression "if ... then ... else ..." from XPath 2.0</p>

<h3>Types</h3>

<p>The expression language has five types:</p>

<ul>
<li>boolean (true or false)</li>
<li>number (an IEEE 754 floating-point number)</li>
<li>string (a sequence of UCS characters)</li>
<li>list (an ordered sequence of objects)</li>
<li>tuple (an unordered set of named objects)</li>
</ul>

<p>The boolean, number and string types can be implicitly converted into
each other, as if using the <code>boolean()</code>, <code>number()</code>
and <code>string()</code> functions. A list can be implicitly converted into 
boolean, the result will be <code>true</code> if the list has at least one element.</p>

<p>An object can be extracted from a tuple either by appending an '.' and a 
symbol, e.g.<br />
<code>$tupleVar.foo</code><br />
or<br />
<code>functionReturningTuple().bar</code><br />
. Or by appending '[]' with an expression, e.g.<br /> 
<code>$tupleVar[$myKey]</code><br />
or<br />
<code>functionReturningTuple()[getKey()]</code><br />
.</p>
<p>With the '[]' notation, a tuple can be used like an hashtable, and is 
most likley implemented with an hashtable.</p>


<h3>Grammar</h3>
<pre>
Expr ::= OrExpr

PrimaryExpr ::= VariableReference
              | '(' Expr ')'
              | Literal
              | Number
              | FunctionCall

VariableReference ::= '$' LSPName

FunctionCall ::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'

FunctionName ::= LSPName ( ':' LSPName )?  /* not NodeType */

Argument ::= Expr

OrExpr ::= AndExpr
         | OrExpr 'or' AndExpr

AndExpr ::= IfExpr
          | AndExpr 'and' IfExpr

IfExpr ::= EqualityExpr
         | 'if' '(' Expr ')' 'then' Expr 'else' EqualityExpr 

EqualityExpr ::= RelationalExpr
               | EqualityExpr '=' RelationalExpr
               | EqualityExpr '!=' RelationalExpr

RelationalExpr ::= AdditiveExpr
                 | RelationalExpr '&lt;' AdditiveExpr
                 | RelationalExpr '>' AdditiveExpr
                 | RelationalExpr '&lt;=' AdditiveExpr
                 | RelationalExpr '>=' AdditiveExpr

AdditiveExpr ::= MultiplicativeExpr
               | AdditiveExpr '+' MultiplicativeExpr
               | AdditiveExpr '-' MultiplicativeExpr

MultiplicativeExpr ::= UnaryExpr
                     | MultiplicativeExpr '*' UnaryExpr
                     | MultiplicativeExpr 'div' UnaryExpr
                     | MultiplicativeExpr 'mod' UnaryExpr

UnaryExpr ::= TupleExpr
            | '-' UnaryExpr

TupleExpr ::= PrimaryExpr
            | TupleExpr '.' LSPName
            | TupleExpr '[' Expr ']'
</pre>

<h3>Lexical</h3>

<pre>
LSPName ::= NCName not containing any '.'

Literal ::= '"' [^"]* '"'
          | "'" [^']* "'"

Number ::= Digits ('.' Digits?)?
         | '.' Digits


NodeType ::= 'comment'
           | 'text'
           | 'processing-instruction'
           | 'node'

Digits ::= [0-9]+
</pre>

<h3>Functions</h3>

<p>Non-namespaced functions are the core functions, defined as in <a href="http://www.w3.org/TR/xpath">XPath</a>:</p>

<ul>
<li>string string(object)</li>
<li>string concat(string, string, string*)</li>
<li>boolean starts-with(string, string)</li>
<li>boolean contains(string, string)</li>
<li>string substring-before(string, string)</li>
<li>string substring-after(string, string)</li>
<li>string substring(string, string, number?)</li>
<li>number string-length(string)</li>
<li>string normalize-space(string)</li>
<li>string translate(string, string, string)</li>
</ul>
<ul>
<li>boolean boolean(object)</li>
<li>boolean not(boolean)</li>
<li>boolean true()</li>
<li>boolean false()</li>
</ul>
<ul>
<li>number number(object)</li>
<li>number floor(number)</li>
<li>number ceiling(number)</li>
<li>number round(number)</li>
</ul>
<ul>
<li>number count(list) - the number of objects in the list</li>
<li>list seq(start, end, step?) - generate a list of numbers with the
specified sequence</li>
</ul>

<p>Namespaced functions are extension functions, see the <a
href="advuserguide.html">Advanced User Guide</a></p>

<h3>Variables</h3>

<p>Unlike XPath, variable name may not be namespaced.</p>

<p>The parameters passed to the LSP page are bound to variables as
strings in the outermost scope.</p>

<p>Attempting to reference an unbound variable gives the empty string
(which may be implicitly converted to the boolean value <code>false</code>
or to the number <code>NaN</code>).</p>


<h2>The stand-alone LSP compiler</h2>

<p>LSP comes with a stand-alone compiler, which compiles LSP pages into files
with <code>.lspc</code> extension. This is currently not useful together with 
Lagoon, but might be useful if LSP is integrated into another system. It is
also useful to check LSP pages for errors.</p>

<p>For a programmatic interface to the LSP compiler, look at the class
<code>nu.staldal.lsp.LSPCompilerHelper</code>.</p>


<h3>Running LSP compiler from command line</h3>

<p>The LSP compiler is invoked by the application class
<code>nu.staldal.lsp.LSPCompilerCLI</code>. The syntax is:</p>
<pre>
lspc [-verbose] [-sourcepath <em>sourcepath</em>] [-d <em>destpath</em>] <em>inputFile</em> ...
</pre>

<p><em>sourcepath</em> specifies where to look for imported files with 
pseudo-absolute URL:s, default is current directory. <em>destpath</em> 
specifies where place generated files, default is current directory.
Multiple input files can be specified. All specified files are compiled 
unconditionally.</p>

<p>If you use any extension libraries, you have to include them in the 
CLASSPATH.</p>


<h3>Using LSP compiler from within Apache Ant</h3>

<p>Define the LSP compiler Ant task in the Ant
build file like this:</p>
<pre>
&lt;taskdef name="lspc" classname="nu.staldal.lsp.LSPCompilerAntTask"&gt;
  &lt;classpath&gt;
    &lt;pathelement location="<em>locationOfLSPJars</em>/lsp.jar" /&gt;
    &lt;pathelement location="<em>locationOfLSPJars</em>/xmlutil.jar" /&gt;
  &lt;/classpath&gt;
&lt;/taskdef&gt;  
</pre>

<p>If you use any extension libraries, you have to include them in the 
classpath as well.</p>

<p>and use the following syntax:</p>
<pre>
&lt;lspc sourcepath="<em>source path</em>"
         <b>destdir</b>="<em>where to place compiled code</em>"
         force="<em>force recompiling of all files</em>"&gt;
      &lt;fileset dir="lsp"&gt;
        &lt;include name="*.lsp" /&gt;
      &lt;/fileset&gt;
&lt;/lspc&gt;
</pre>

<p>If the <code>sourcepath</code> attriute is omitted, the project base 
path is used. If <code>force</code> is not set, files are only compiled if 
the source file is newer than the target file (<strong>Note:</strong> 
imported files are not checked, changing an imported file will not trigger 
recompile).</p>

</body>
</html>

