<?xml version="1.0" encoding="iso-8859-1"?>
<html>
<head><title>LSP User Guide</title></head>
<link rel="stylesheet" type="text/css" href="manual.css" />
<body>
<h1>LSP User Guide</h1>

<h2>Overview</h2>

<p>LSP is an advanced XML based web template language.</p>

<p>LSP is fully based on XML and namespaces. This means that it's easy
to efficiently use LSP together with other XML technologies, such as
XSLT (for example, you can process the output of LSP with XSLT).</p>

<p>LSP pages can be used as an alternative to JSP in a 
<a href="http://java.sun.com/products/servlet">Java Servlet</a> 
based web application. See <a href="lsp-servlet.html">here</a>.</p>


<h2>LSP basics</h2>

<p>An LSP page is a well-formed XML document, composed of elements from
the LSP namespace and from other namespaces (including the null
namespace). The document root element may, but doesn't have to, be in
the LSP namespace.</p>

<p>The namespace URI for LSP is
<code>http://staldal.nu/LSP/core</code>. In this document, it's assumed
that this namespace is mapped to the prefix <code>lsp</code>, however
any prefix may be used.</p>

<p>An LSP page is processed by interpreting all LSP elements, and
sending all non-LSP elements (unless they are extension elements), 
all character data and all processing instructions to the output 
(subject to <a href="#template">template processing</a>). 
However, some LSP element can alter the output of parts of the LSP page. 
Comments in the LSP page are ignored. Any DTD in the LSP page is not sent 
to the output.</p>

<p>To ensure high performance, LSP pages are compiled into bytecode, 
which can then be executed several times, possibly with a different set 
of parameters. Unless otherwise stated, all processing occurs when the page 
is executed.</p>

<p>It's simple to start using LSP in a static HTML (or some XML
based markup language) page. Just add a declaration for the LSP
namespace (<code>xmlns:lsp="http://staldal.nu/LSP/core"</code>) in the
root element and add LSP elements. However, you must
ensure that the HTML page is in well-formed XML format.</p>


<h2>LSP elements</h2>

<p>This section describes all elements in the LSP namespace. An
attribute name in <b>bold</b> means this attribute is required. An
attribute value specification surrounded by curly braces
(<code>{}</code>) means that the attribute value is processed as a <a
href="#template">template</a>.</p>

<p>In elements marked with <code>(whitespace stripping)</code>,
any whitespace node immediatly after the start-tag and before 
the end-tag is stripped. This stripping can be inhibited by setting
the <code>xml:space</code> attribute to <code>preserve</code>, or by 
contain the whitespace in an <code>lsp:root</code> element. The prupose of this whitespace stripping is to make it possible to
format the LSP source in a readable way without getting a lot of unnessecary 
whitespace in the output.</p>

<h4>lsp:import</h4>

<p class="element-syntax">
<a name="element-import"></a>&lt;lsp:import<br />
&#160;&#160;<b>file</b> = <var>URL</var>&#160;/&gt;
</p>

<p>The <code>lsp:import</code> includes a file when the page is
compiled. Any LSP elements and templates in the included file are
processed.</p>


<h4>lsp:root</h4>

<p class="element-syntax">
<a name="element-root"></a>&lt;lsp:root&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:root&gt;
</p>

<p>The <code>lsp:root</code> element simply outputs all of its content.
Useful as document root element in files to be <code>import</code>ed. 
The <code>lsp:root</code> element can be nested.</p>


<h4>lsp:processing-instruction</h4>

<p class="element-syntax">
<a name="element-processing-instruction"></a>
&lt;lsp:processing-instruction<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> &#160; -(lsp:processing-instruction, lsp:element, lsp:attribute) --&gt;<br />
&lt;/lsp:processing-instruction&gt;
</p>

<p>The <code>lsp:processing-instruction</code> element creates a
processing instruction in the output. The <code>name</code> attribute
is used as the processing instruction target, and the character data of
the content is used as the processing instruction data.
<code>lsp:processing-instruction</code> may <em>not</em> be nested.</p>


<h4>lsp:element</h4>

<p class="element-syntax">
<a name="element-element"></a>
&lt;lsp:element<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
&#160;&#160;namespace = { <var>URI</var> }&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:element&gt;
</p>

<p>The <code>lsp:element</code> element creates an
element with a computed name in the output. The <code>name</code> attribute
is used as the local name of the element. The <code>namespace</code> attribute
is used as the namespace URI of the element (if omitted, the generated element
will be in the default namespace in effect, set <code>namespace</code> 
attribute to the empty string to explicitly place the element in the null 
namespace).</p>

<p><em>Note:</em> unlike the similar element in 
XSLT, the value of the <code>name</code> attribute may not be a QName.</p>


<h4>lsp:attribute</h4>

<p class="element-syntax">
<a name="element-attribute"></a>
&lt;lsp:attribute<br />
&#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
&#160;&#160;namespace = { <var>URI</var> }<br />
&#160;&#160;<b>value</b> = { <var>any</var> }/&gt;
</p>

<p>The <code>lsp:attribute</code> element creates an attribute with a 
computed name in the output. The attribute is attached to the enclosing 
element (which may be either an <code>lsp:element</code> or a normal literal element).
The <code>name</code> attribute is used as the local name of the attribute. The <code>namespace</code> attribute
is used as the namespace URI of the atribute (if omitted, the created attribute
will be in the null namespace). May not be used to create namespace 
declarations, the value of the <code>name</code> attribute may not be "<code>xmlns</code>".
It's an error to add an attribute with the same name as an already 
existing attribute, this error cannot be detected at compile time, and will 
result in undefined behaviour at runtime. If the <code>name</code> 
expression evaluates to the empty string, no attribute will be created.</p>

<p>Note that it's not possible to nest an <code>lsp:attribute</code> element
inside <code>lsp:if</code> or <code>lsp:choose</code>. To conditionally add 
an attribute, use the <code>if ... then ... else ...</code> expression and
the fact that <code>lsp:attribute</code> will not add any attribute if 
<code>name</code> is the empty string. E.g.</p>

<pre>
&lt;option value="4711"&gt;
&lt;lsp:attribute name="{if (cond) then 'selected' else ''}" value="selected"/&gt;
foo&lt;/option&gt;
</pre>

<p>Any whitespace immediately before an <code>lsp:attribute</code> element 
will be stripped, unless the <code>xml:space</code> attribute is set to <code>preserve</code>.</p>

<p><em>Note:</em> unlike the similar element in XSLT, the value of the 
<code>name</code> attribute may not be a QName.</p>


<h4>lsp:value-of</h4>

<p class="element-syntax">
<a name="element-value-of"></a>
&lt;lsp:value-of<br />
&#160;&#160;<b>select</b> = <var>string-expression</var><br />
&#160;&#160;disable-output-escaping = <var>boolean</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any</var> --&gt;<br />
&lt;/lsp:value-of&gt;
</p>

<p>The <code>select</code> expression is evaluated, and converted to
string (as if by a call to the <code>string()</code> function).
That string is outputted. Any content of the <code>lsp:value-of</code> 
element is ignored (may be used as sample data during development).</p>

<p>If the <code>disable-output-escaping</code> attribute is specified and 
set to "yes" or "disable-output-escaping", the noraml escaping of 
characters &amp; and &lt; is disabled. This allows you to e.g. include 
a XML or HTML fragment as a string. <em>Note:</em> This can cause the 
output to be ill-formed.</p>


<h4>lsp:if</h4>

<p class="element-syntax">
<a name="element-if"></a>
&lt;lsp:if<br />
&#160;&#160;<b>test</b> = <var>boolean-expression</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any (whitespace stripping)</var> --&gt;<br />
&lt;/lsp:if&gt;
</p>

<p>The <code>test</code> expression is evaluated, and converted to
boolean (as if by a call to the <code>boolean()</code> function).
If the result is true, the content of the <code>lsp:if</code> element
is outputted, otherwise nothing outputted.</p>


<h4>lsp:choose</h4>

<p class="element-syntax">
<a name="element-choose"></a>
&lt;lsp:choose&gt;<br />
&#160;&#160;&lt;!-- Content: (lsp:when+, lsp:otherwise?) --&gt;<br />
&lt;/lsp:choose&gt;
</p>


<h4>lsp:when</h4>

<p class="element-syntax">
<a name="element-when"></a>
&lt;lsp:when<br />
&#160;&#160;<b>test</b> = <var>boolean-expression</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any (whitespace stripping)</var> --&gt;<br />
&lt;/lsp:when&gt;
</p>


<h4>lsp:otherwise</h4>

<p class="element-syntax">
<a name="element-otherwise"></a>
&lt;lsp:otherwise&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any (whitespace stripping)</var> --&gt;<br />
&lt;/lsp:otherwise&gt;
</p>

<p>The <code>test</code> expression for each <code>lsp:when</code> element is
evaluated in turn, and converted to boolean (as if by a call to the <code>boolean()</code> function). The content of the first, and only the first, <code>lsp:when</code> element whose test is true is outputted. If no <code>lsp:when</code> element is true, the content of the <code>lsp:otherwise</code> element is outputted. If no <code>lsp:when</code> element is true and if there is no <code>lsp:otherwise</code> element, nothing is outputted.</p>


<h4>lsp:for-each</h4>

<p class="element-syntax">
<a name="element-for-each"></a>
&lt;lsp:for-each<br />
&#160;&#160;<b>select</b> = <var>list-expression</var><br />
&#160;&#160;<b>var</b> = <var>variable name</var>&gt;<br />
&#160;&#160;status = <var>variable name</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any (whitespace stripping)</var> --&gt;<br />
&lt;/lsp:for-each&gt;
</p>

<p>The <code>select</code> expression is evaulated, and is expected to be of
type list, otherwise an error occurs. The content of the <code>lsp:for-each</code> element
is outputted once for each object in the list, with the variable
specified in the <code>var</code> attribute bound to the current object in
the list. If the <code>status</code> attribute is specified, a variable with 
that name is bound to an interator status object. Any variable with the 
same name in the enclosing scope is shadowed.</p>

<p>An iterator status object is a tuple with the following elements:
<ul>
<li><code>index</code> - a number the position in the list, starting from 1</li>
<li><code>first</code> - a boolean indicating if this is the first element</li>
<li><code>last</code> - a boolean indicating if this is the last element</li>
<li><code>even</code> - a boolean indicating if this is an even element</li>
<li><code>odd</code> - a boolean indicating if this is an odd element</li>
</ul>
</p>

<h4>lsp:let</h4>

<p class="element-syntax">
<a name="element-let"></a>
&lt;lsp:let<br />
&#160;&#160;<i>var1</i> = <var>expression</var><br />
&#160;&#160;<i>var2</i> = <var>expression</var><br />
&#160;&#160;<i>...</i><br />
&#160;&#160;<i>varn</i> = <var>expression</var>&gt;<br />
&#160;&#160;&lt;!-- Content: <var>any (whitespace stripping)</var> --&gt;<br />
&lt;/lsp:let&gt;
</p>

<p>Each expression is evaulated, and the value is bound to a variable with the 
same name as the attribute within the body of the <code>lsp:let</code> element.
Any variables with the same name in the enclosing scope are shadowed.</p>


<a name="template"><h2>Templates</h2></a>

<p>All attribute values to non-LSP elements and the values of
some attributes to LSP elements are processed as templates. This means
that it may contain LSP expressions surrounded by curly braces
(<code>{}</code>). A such expression is evaluated and the expression
(together with the curly braces) is replaced with its string value. To
actually include a literal curly brace, use a double curly brace.</p>


<h2>LSP Expressions</h2>

<p>The expression language used in LSP is based on <a href="http://www.w3.org/TR/xpath">XPath</a>.
It's essentially XPath 1.0 without nodesets, with the conditional expression "if ... then ... else ..." from XPath 2.0.</p>

<h3>Types</h3>

<p>The expression language has five types:</p>

<ul>
<li>boolean (true or false)</li>
<li>number (an IEEE 754 floating-point number)</li>
<li>string (a sequence of UCS characters)</li>
<li>list (an ordered sequence of objects)</li>
<li>tuple (an unordered set of named objects)</li>
</ul>

<p>The boolean, number and string types can be implicitly converted into
each other, as if using the <code>boolean()</code>, <code>number()</code>
and <code>string()</code> functions. A list can be implicitly converted into 
boolean, the result will be <code>true</code> if the list has at least one element.</p>

<p>An object can be extracted from a tuple either by appending an '.' and a 
symbol, e.g.<br />
<code>$tupleVar.foo</code><br />
or<br />
<code>functionReturningTuple().bar</code><br />
. Or by appending '[]' with an expression, e.g.<br /> 
<code>$tupleVar[$myKey]</code><br />
or<br />
<code>functionReturningTuple()[getKey()]</code><br />
.</p>
<p>With the '[]' notation, a tuple can be used like an hashtable, and is 
most likley implemented with an hashtable. Note that the value will be 
converted to a string before used as key for lookup, this means that a 
mapping with another type of key will not be found by LSP (e.g. you cannot 
use a Java Number).</p>


<h3>Grammar</h3>
<pre>
Expr ::= OrExpr

PrimaryExpr ::= VariableReference
              | '(' Expr ')'
              | Literal
              | Number
              | FunctionCall

VariableReference ::= '$' LSPName

FunctionCall ::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'

FunctionName ::= LSPName ( ':' LSPName )?  /* not NodeType */

Argument ::= Expr

OrExpr ::= AndExpr
         | OrExpr 'or' AndExpr

AndExpr ::= IfExpr
          | AndExpr 'and' IfExpr

IfExpr ::= EqualityExpr
         | 'if' '(' Expr ')' 'then' Expr 'else' EqualityExpr 

EqualityExpr ::= RelationalExpr
               | EqualityExpr '=' RelationalExpr
               | EqualityExpr '!=' RelationalExpr

RelationalExpr ::= AdditiveExpr
                 | RelationalExpr '&lt;' AdditiveExpr
                 | RelationalExpr '>' AdditiveExpr
                 | RelationalExpr '&lt;=' AdditiveExpr
                 | RelationalExpr '>=' AdditiveExpr

AdditiveExpr ::= MultiplicativeExpr
               | AdditiveExpr '+' MultiplicativeExpr
               | AdditiveExpr '-' MultiplicativeExpr

MultiplicativeExpr ::= UnaryExpr
                     | MultiplicativeExpr '*' UnaryExpr
                     | MultiplicativeExpr 'div' UnaryExpr
                     | MultiplicativeExpr 'mod' UnaryExpr

UnaryExpr ::= TupleExpr
            | '-' UnaryExpr

TupleExpr ::= PrimaryExpr
            | TupleExpr '.' LSPName
            | TupleExpr '[' Expr ']'
</pre>

<h3>Lexical</h3>

<pre>
LSPName ::= NCName not containing any '.'

Literal ::= '"' [^"]* '"'
          | "'" [^']* "'"

Number ::= Digits ('.' Digits?)?
         | '.' Digits


NodeType ::= 'comment'
           | 'text'
           | 'processing-instruction'
           | 'node'

Digits ::= [0-9]+
</pre>

<h3>Functions</h3>

<p>Non-namespaced functions are the core functions, defined as in <a href="http://www.w3.org/TR/xpath">XPath</a>:</p>

<ul>
<li>string string(object)</li>
<li>string concat(string, string, string*)</li>
<li>boolean starts-with(string, string)</li>
<li>boolean contains(string, string)</li>
<li>string substring-before(string, string)</li>
<li>string substring-after(string, string)</li>
<li>string substring(string, string, number?)</li>
<li>number string-length(string)</li>
<li>string normalize-space(string)</li>
<li>string translate(string, string, string)</li>
</ul>
<ul>
<li>boolean boolean(object)</li>
<li>boolean not(boolean)</li>
<li>boolean true()</li>
<li>boolean false()</li>
</ul>
<ul>
<li>number number(object)</li>
<li>number floor(number)</li>
<li>number ceiling(number)</li>
<li>number round(number)</li>
</ul>
<ul>
<li>number count(list) - the number of objects in the list</li>
<li>list seq(start, end, step?) - generate a list of numbers with the
specified sequence</li>
</ul>

<p>Namespaced functions are extension functions in LSP Extension Libraries</p>


<h3>Variables</h3>

<p>Unlike XPath, variable name may not be namespaced.</p>

<p>The parameters passed to the LSP page are bound to variables 
in the outermost scope.</p>

<p>It's an error to attempt to reference an unbound variable.</p>


<h2>The stand-alone LSP compiler</h2>

<p>LSP comes with a stand-alone compiler, which compiles LSP pages into Java 
<code>.class</code> files. It is also useful to check LSP pages for errors.
The LSP compiler is contained in <code>lspc.jar</code>.</p>

<p>For a programmatic interface to the LSP compiler, look at the class
<code>nu.staldal.lsp.compiler.LSPCompilerHelper</code>.</p>

<p>The LSP compiler uses the third-party library <a href="http://jakarta.apache.org/bcel/">BCEL</a>.
The BCEL library is only needed when compiling LSP pages, not when 
executing the compiled code.</p>


<h3>Running LSP compiler from command line</h3>

<p>The LSP compiler is invoked by the application class
<code>nu.staldal.lsp.compiler.LSPCompilerCLI</code>. The syntax is:</p>
<pre>
lspc [-verbose] [-force] [-sourcepath <em>sourcepath</em>] [-d <em>destdir</em>] <em>inputFile</em> ...
</pre>

<p><em>sourcepath</em> specifies where to look for imported files with 
relative URL:s, may contain multiple directories separated by ';' (will 
search the directory where the source file is as well).
<em>destdir</em> specifies where place generated files, default is current directory.
Multiple input files can be specified. If <code>-force</code> is not specified, 
files are only compiled if the source file is newer than the target file 
(imported files are also checked, changing an imported file will trigger 
recompile).</p> 

<p>You have to put bcel.jar in CLASSPATH. If you use any extension libraries, 
you have to include them in the CLASSPATH as well.</p>


<h3>Using LSP compiler from within Apache Ant</h3>

<p>Define the LSP compiler Ant task in the Ant
build file like this:</p>
<pre>
&lt;taskdef name="lspc" classname="nu.staldal.lsp.compiler.LSPCompilerAntTask"&gt;
  &lt;classpath&gt;
    &lt;pathelement location="<em>locationOfLSPJars</em>/lspc.jar" /&gt;
    &lt;pathelement location="<em>locationOfLSPJars</em>/lsprt.jar" /&gt;
    &lt;pathelement location="<em>locationOfBCELJars</em>/bcel.jar" /&gt;
  &lt;/classpath&gt;
&lt;/taskdef&gt;  
</pre>

<p>If you use any extension libraries, you have to include them in the 
classpath as well.</p>

<p>and use the following syntax:</p>
<pre>
&lt;lspc sourcepath="<em>sourcepath</em>"
         <b>destdir</b>="<em>where to place compiled code</em>"
         force="<em>force recompiling of all files</em>"&gt;
      &lt;fileset dir="lsp"&gt;
        &lt;include name="*.lsp" /&gt;
      &lt;/fileset&gt;
&lt;/lspc&gt;
</pre>

<p><em>sourcepath</em> specifies where to look for imported files with 
relative URL:s, may contain multiple directories separated by ';' or ':' 
(will search the directory where the source file is as well).
If <code>force</code> is not set, files are only compiled if 
the source file is newer than the target file (imported files are also checked, 
changing an imported file will trigger recompile).</p>

</body>
</html>

